<html>

<head>
    <script src='https://cdn.jsdelivr.net/npm/chart.js@4.4.4/dist/chart.umd.min.js'></script>
    <script src='https://cdn.jsdelivr.net/npm/chartjs-plugin-datalabels@2.0.0'></script>
    <script
        src='https://cdn.jsdelivr.net/npm/chartjs-adapter-date-fns/dist/chartjs-adapter-date-fns.bundle.min.js'></script>
    <link rel='icon' type='image/x-icon'
        href='data:image/x-icon;base64,AAABAAEAEBAAAAEAIABoBAAAFgAAACgAAAAQAAAAIAAAAAEAIAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAKcAAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAAqAAAAAAAAAAAAAAAAAAAALIAAAD/AAAA4AAAANwAAADcAAAA3AAAANwAAADcAAAA3AAAANwAAADcAAAA4AAAAP8AAACxAAAAAAAAAKYAAAD/AAAAuwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAC/AAAA/wAAAKkAAAD6AAAAzAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAN8AAAD/AAAA+gAAAMMAAAAAAAAAAgAAAGsAAABrAAAAawAAAGsAAABrAAAAawAAAGsAAABrAAAADAAAAAAAAADaAAAA/wAAAPoAAADDAAAAAAAAAIsAAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAANEAAAAAAAAA2gAAAP8AAAD6AAAAwwAAAAAAAAAAAAAAMgAAADIAAAAyAAAAMgAAADIAAAAyAAAAMgAAADIAAAAFAAAAAAAAANoAAAD/AAAA+gAAAMMAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADaAAAA/wAAAPoAAADDAAAAAAAAADwAAAB8AAAAAAAAAGAAAABcAAAAAAAAAH8AAABKAAAAAAAAAAAAAAAAAAAA2gAAAP8AAAD6AAAAwwAAAAAAAADCAAAA/wAAACkAAADqAAAA4QAAAAAAAAD7AAAA/wAAALAAAAAGAAAAAAAAANoAAAD/AAAA+gAAAMMAAAAAAAAAIwAAAP4AAAD/AAAA/wAAAGAAAAAAAAAAAAAAAMkAAAD/AAAAigAAAAAAAADaAAAA/wAAAPoAAADDAAAAAAAAAAAAAAAIAAAAcAAAABkAAAAAAAAAAAAAAAAAAAAAAAAAEgAAAAAAAAAAAAAA2gAAAP8AAAD7AAAAywAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAN4AAAD/AAAAqwAAAP8AAACvAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAALIAAAD/AAAAsgAAAAAAAAC5AAAA/wAAAMoAAADAAAAAwAAAAMAAAADAAAAAwAAAAMAAAADAAAAAwAAAAMkAAAD/AAAAvAAAAAAAAAAAAAAAAAAAAKwAAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAArQAAAAAAAAAAwAMAAIABAAAf+AAAP/wAAD/8AAAgBAAAP/wAAD/8AAA//AAAJIwAADHEAAA//AAAP/wAAB/4AACAAQAAwAMAAA=='>
</head>
<style>
    h2 {
        padding: 0px 20px 0px 20px;
    }

    :root {
        color-scheme: dark;
        font-family: Helvetica, sans-serif;
    }

    canvas {
        user-select: none;
    }

    @media (prefers-color-scheme: light) {
        body {
            background-color: #eee;
        }
    }

    @media (prefers-color-scheme: dark) {
        body {
            background-color: #1c2227;
            color: #e2e1d7;
        }
    }

    .canvas-container {
        width: 900;
        /* overflow-x: scroll; */
        margin-left: 20px;
        text-align: center; 
    }
    .canvas-container button {
        /* position: absolute; */
        top: 50%;
    }

    .header {
        margin-top: 20px;
        margin-left: 20px;
    }

    .header p {
        display: inline;
        vertical-align: top;
        line-height: 28px;
        margin-right: 20px;
    }

    .header {
        display: flex;
        justify-content: space-between;
    }

    .header .stats {
        margin-top: 20px;
        line-height: 28px;
    }

    .header h1 {
        display: inline;
        vertical-align: top;
        line-height: 28px;
    }

    .filters {
        margin-left: 20px;
        display: flex;
        justify-content: space-between;
        width: 80%;
    }
</style>

<body>
    <div class='header'>
        <h1>Robot Framework Dashboard {{ date }}</h1>
        <div class='stats'>
            <p id='runCount'></p>
            <p id='suiteCount'></p>
            <p id='testCount'></p>
            <p id='keywordCount'></p>
        </div>
    </div>

    <div class='filters'>
        <div>
            <label for='runs'>Runs</label>
            <select id='runs'></select>
        </div>
        <div>
            <label for='tag'>Tag</label>
            <select id='tag'></select>
        </div>
        <div>
            <label for='fromDate'>From Date</label>
            <input id='fromDate' type='date'></input>
        </div>
        <div>
            <label for='fromTime'>From Time</label>
            <input id='fromTime' type='time'></input>
        </div>
        <div>
            <label for='toDate'>To Date</label>
            <input id='toDate' type='date'></input>
        </div>
        <div>
            <label for='toTime'>To Time</label>
            <input id='toTime' type='time'></input>
        </div>
        <div>
            <button id='clearFilters'>Clear Filters</button>
        </div>
    </div>

    <h2 id="runTitle">Run Statistics</h2>
    <div style='display: flex'>
        <div class='canvas-container'>
            <canvas id='runStatistics' width='900' , height='540'></canvas>
        </div>
        <div class='canvas-container'>
            <canvas id='runsOverTime' width='900' , height='540'></canvas>
            <button onclick='swap_runs_over_time()'>Swap Bar/Line View</button>
        </div>
    </div>
    <h2>Suite Statistics</h2>
    <div style='display: flex'>
        <div class='canvas-container'>
            <canvas id='suiteStatistics' width='900' , height='540'></canvas>
        </div>
        <div class='canvas-container'>
            <canvas id='suitesOverTime' width='900' , height='540'></canvas>
        </div>
    </div>
    <h2>Test Statistics</h2>
    <div style='display: flex'>
        <div class='canvas-container'>
            <canvas id='testStatistics' width='900' , height='540'></canvas>
        </div>
        <div class='canvas-container'>
            <canvas id='testsOverTime' width='900' , height='540'></canvas>
        </div>
    </div>
    <h2>Keyword Statistics</h2>
    <div style='display: flex'>
        <div class='canvas-container'>
            <canvas id='keywordStatistics' width='900' , height='540'></canvas>
        </div>
        <div class='canvas-container'>
            <canvas id='keywordsOverTime' width='900' , height='540'></canvas>
        </div>
    </div>

</body>
<script>
    // theme
    if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        Chart.defaults.color = '#e2e1d7';
        Chart.defaults.borderColor = 'rgba(255,255,255,0.1)';
        Chart.defaults.backgroundColor = 'rgba(255,255,0,0.1)';
        Chart.defaults.elements.line.borderColor = 'rgba(255,255,0,0.4)';
    }
    // prepare input data
    var runs = {{ runs }}.sort((a, b) => new Date(a.run_start).getTime() - new Date(b.run_start).getTime());
    var suites = {{ suites }}.sort((a, b) => new Date(a.run_start).getTime() - new Date(b.run_start).getTime());
    var tests = {{ tests }}.sort((a, b) => new Date(a.run_start).getTime() - new Date(b.run_start).getTime());
    // var keywords = {{keywords}}.sort((a, b) => new Date(a.run_start).getTime() - new Date(b.run_start).getTime());

    // set default values
    document.getElementById('runCount').innerText = 'Runs: ' + runs.length
    document.getElementById('testCount').innerText = 'Tests: ' + tests.length
    document.getElementById('suiteCount').innerText = 'Suites: ' + suites.length
    document.getElementById('keywordCount').innerText = 'Keywords: ' + {{ keywords }}
    set_lowest_highest_dates(runs)

    // initialize graphs and filters
    add_runs_in_select(runs)
    add_tags_in_select(runs)
    var runStatisticsGraph
    var runsOverTimeGraph
    var swapRunsOverTimeView = true
    update_all_graphs(swapRunsOverTimeView)

    // eventlisteners for filters
    document.getElementById('runs').addEventListener('change', update_all_graphs)
    document.getElementById('tag').addEventListener('change', update_all_graphs)
    document.getElementById('fromDate').addEventListener('change', update_all_graphs)
    document.getElementById('fromTime').addEventListener('change', update_all_graphs)
    document.getElementById('toDate').addEventListener('change', update_all_graphs)
    document.getElementById('toTime').addEventListener('change', update_all_graphs)
    document.getElementById('clearFilters').addEventListener('click', clear_filters)

    function set_lowest_highest_dates(runs) {
        var dates = []
        for (run of runs) {
            dates.push(new Date(run.run_start))
        }
        var lowest = new Date(Math.min.apply(null,dates));
        var highest = new Date(Math.max.apply(null,dates));
        var tzoffset = (new Date()).getTimezoneOffset() * 60000;
        lowest = new Date((new Date(lowest - tzoffset)).getTime() + -1*60000) // this is to account for seconds in the initial filter value
        highest =new Date((new Date(highest - tzoffset)).getTime() + 1*60000) // this is to account for seconds in the initial filter value
        document.getElementById('fromDate').value = lowest.toISOString().split('T')[0]
        document.getElementById('fromTime').value = (lowest.toISOString().split('T')[1]).substring(0, 5)
        document.getElementById('toDate').value = highest.toISOString().split('T')[0]
        document.getElementById('toTime').value = (highest.toISOString().split('T')[1]).substring(0, 5)
    }

    function update_all_graphs() {
        var filtered = filter_runs(runs)
        filtered = filter_tags(filtered)
        filtered = filter_dates(filtered)

        // set titles with amount of filtered runs
        document.getElementById('runTitle').innerText = `Run Statistics (${Object.keys(filtered).length} runs)`

        // destroy and create new graphs
        if (runStatisticsGraph) { runStatisticsGraph.destroy() }
        if (runsOverTimeGraph) { runsOverTimeGraph.destroy() }
        create_run_statistics_graph(filtered)
        create_runs_over_time_graph(filtered, swapRunsOverTimeView)
    }

    function swap_runs_over_time() {
        runsOverTimeGraph.destroy()
        if (swapRunsOverTimeView) {
            swapRunsOverTimeView = false
            update_all_graphs()
        } else {
            swapRunsOverTimeView = true
            update_all_graphs()
        }
    }

    function filter_runs(runs) {
        var run = document.getElementById('runs').value
        var filtered = {}
        for (const [key, value] of Object.entries(runs)) {
            if (run != 'All' && value.name != run) {
                continue
            } else {
                filtered[key] = value
            }
        }
        return filtered
    }

    function filter_tags(runs) {
        var tag = document.getElementById('tag').value
        var filtered = {}
        for (const [key, value] of Object.entries(runs)) {
            if (tag != 'All') {
                var runTags = value.tags.split(',')
                for (runTag of runTags) {
                    if (tag != runTag) {
                        continue
                    } else {
                        filtered[key] = value
                    }
                }
            } else {
                filtered = runs
            }
        }
        return filtered
    }

    function filter_dates(runs) {
        var fromDate = document.getElementById('fromDate').value
        var fromTime = document.getElementById('fromTime').value
        var toDate = document.getElementById('toDate').value
        var toTime = document.getElementById('toTime').value

        var filtered = {}
        if (fromDate && fromTime && toDate && toTime) {
            var fromDateTime = new Date(`${fromDate} ${fromTime}:00`)
            var toDateTime = new Date(`${toDate} ${toTime}:00`)
            if (fromDateTime <= toDateTime) {
                for (const [key, value] of Object.entries(runs)) {
                    var run_start = new Date(value.run_start)
                    if (run_start < fromDateTime || run_start > toDateTime) {
                        continue
                    } else {
                        filtered[key] = value
                    }
                }
            } else {
                // you end up here if fromDate > toDate
                alert('Filter error: The selected from date + time is later than your selected to date + time. Date filter has not been applied!')
                filtered = runs
            }
        } else {
            // no dates or not all value are provided
            filtered = runs
        }
        return filtered
    }

    function clear_filters() {
        document.getElementById('runs').value = 'All'
        document.getElementById('tag').value = 'All'
        set_lowest_highest_dates(runs)
        update_all_graphs()
    }

    function add_runs_in_select(runs) {
        var runOptions = []
        for (run of runs) {
            if (!runOptions.includes(run.name)) {
                runOptions.push(run.name)
            }
        }
        runsSelect = document.getElementById('runs');
        runsSelect.options[runsSelect.options.length] = new Option('All', 'All');
        for (runOption of runOptions) {
            runsSelect.options[runsSelect.options.length] = new Option(runOption, runOption);
        }
    }

    function add_tags_in_select(runs) {
        var tags = []
        for (run of runs) {
            var runTags = run.tags.split(',')
            for (tag of runTags) {
                if (!tags.includes(tag) && tag != '') {
                    tags.push(tag)
                }
            }
        }
        tagsSelect = document.getElementById('tag');
        tagsSelect.options[tagsSelect.options.length] = new Option('All', 'All');
        for (tag of tags) {
            tagsSelect.options[tagsSelect.options.length] = new Option(tag, tag);
        }
    }

    function create_run_statistics_graph(filtered) {
        var [passed, failed, skipped, labels] = [[],[],[],[]]
        for (const [key, value] of Object.entries(filtered)) {
            passed.push(value.passed)
            failed.push(value.failed)
            skipped.push(value.skipped)
            labels.push(`${value.full_name}: ${value.run_start}`)
        }

        var runStatisticsData
        runStatisticsData = {
            labels: labels,
            datasets: [
                {
                    label: 'Failed',
                    data: failed,
                    backgroundColor: '#ce3e01',
                    stack: 'Stack 0',
                },
                {
                    label: 'Skipped',
                    data: skipped,
                    backgroundColor: '#fed84f',
                    stack: 'Stack 0',
                },
                {
                    label: 'Passed',
                    data: passed,
                    backgroundColor: '#97bd61',
                    stack: 'Stack 0',
                },
            ]
        };

        Chart.register(ChartDataLabels);
        runStatisticsGraph = new Chart('runStatistics', {
            type: 'bar',
            data: runStatisticsData,
            options: {
                scales: {
                    x: {
                        ticks: {
                            display: true,
                            callback: function (value) {
                                return this.getLabelForValue(value).split(':')[0]
                            },
                        },
                        title: {
                            display: true,
                            text: 'Run'
                        }
                    },
                    y: {
                        stacked: true,
                        title: {
                            display: true,
                            text: 'Amount Of Tests'
                        },
                        grace: '5%'
                    }
                },
                interaction: {
                    mode: 'x'
                },
                responsive: false,
                plugins: {
                    legend: {
                        display: false,
                        labels: {
                            family: 'Helvetica, sans-serif',
                        }
                    },
                    datalabels: {
                        color: '#000000',
                        align: 'center',
                        anchor: 'center',
                        formatter: function (value) {
                            if (value > 0) {
                                return value
                            } else {
                                value = '';
                                return value;
                            }
                        }
                    },
                    title: {
                        display: true,
                        text: 'Run Statistics'
                    }
                }
            }
        });
    }

    function create_runs_over_time_graph(filtered, swapRunsOverTimeView) {
        if (swapRunsOverTimeView) {
            var [labels, data] = [[], {0: []}]
            // prepare data for bar chart
            for (const [key, value] of Object.entries(filtered)) {
                labels.push(`${value.full_name}: ${value.run_start}`)
                var dataLength = data[0].length
                if (data[value.name]) {
                    // add 0 to all not matching, and value.elapsed to matching
                    data[value.name].push(Math.round(value.elapsed_s))
                } else {
                    // add longest amount of 0's to matched and 1 zero to not matching
                    data[value.name] = []
                    for (let step = 0; step < dataLength; step++) {
                        data[value.name].push(0)
                    }
                    data[value.name].push(Math.round(value.elapsed_s))
                }
                // add 0 to every other value
                for (d in data) {
                    if (d != value.name) {
                        data[d].push(0)
                    }
                }
            }
            delete data[0]
            var runStatisticsData = {
                labels: labels,
                datasets: [],
            }
            for (key in data) {
                runStatisticsData['datasets'].push({
                    label: key,
                    data: data[key],
                    stack: 'Stack 0'
                })

            }
            // create graph
            runsOverTimeGraph = new Chart('runsOverTime', {
                type: 'bar',
                data: runStatisticsData,
                options: {
                    scales: {
                        x: {
                            ticks: {
                                display: true,
                                callback: function (value) {
                                    return this.getLabelForValue(value).split(':')[0]
                                },
                            },
                            title: {
                                display: true,
                                text: 'Run'
                            }
                        },
                        y: {
                            stacked: true,
                            title: {
                                display: true,
                                text: 'Duration'
                            },
                            grace: '5%'
                        }
                    },
                    interaction: {
                        mode: 'x'
                    },
                    responsive: false,
                    plugins: {
                        legend: {
                            display: false,
                            labels: {
                                family: 'Helvetica, sans-serif',
                            }
                        },
                        datalabels: {
                            color: '#000000',
                            align: 'center',
                            anchor: 'center',
                            formatter: function (value) {
                                if (value > 0) {
                                    return value
                                } else {
                                    value = '';
                                    return value;
                                }
                            }
                        },
                        title: {
                            display: true,
                            text: 'Run Statistics'
                        }
                    }
                }
            });
        } else {
            var [labels, datasets, sets] = [[], [], {}]
            // prepare data in the correct format
            for (const [key, value] of Object.entries(filtered)) {
                var full_name = value.full_name
                var run_start = new Date(value.run_start)
                var elapsed_s = Math.round(value.elapsed_s)
                if (labels.includes(full_name)) {
                    var values = sets[full_name]
                    values.push({ x: run_start, y: elapsed_s })
                    sets[full_name] = values
                } else {
                    labels.push(full_name)
                    sets[full_name] = [{ x: run_start, y: elapsed_s }]
                }
            }
            for (const [key, value] of Object.entries(sets)) {
                datasets.push({ label: key, fill: false, borderDash: [5, 5], data: value })
            }
            // create graph
            runsOverTimeGraph = new Chart('runsOverTime', {
                type: 'line',
                data: {
                    datasets: datasets
                },
                options: {
                    responsive: false,
                    plugins: {
                        title: {
                            text: 'Run Duration Over Time',
                            display: true
                        },
                        datalabels: {
                            display: false,
                        },
                        legend: {
                            display: true,
                            position: 'right',
                            labels: {
                                family: 'Helvetica, sans-serif',
                                color: '#e2e1d7'
                            }
                        },
                    },
                    scales: {
                        x: {
                            type: 'time',
                            time: {
                                tooltipFormat: 'dd.MM.yyyy - HH:mm:ss.SSS'
                            },
                            title: {
                                display: true,
                                text: 'Date'
                            }
                        },
                        y: {
                            title: {
                                display: true,
                                text: 'Elapsed (seconds)'
                            },
                            grace: '5%'
                        }
                    }
                }
            });
        }
    }
</script>

<body>

</html>

<!-- var chart = new CanvasJS.Chart('chartContainer',
                               {
  title: {
    text: 'How long an event occurred for on a given day'
  },
  axisY: {
    minimum: (new Date(2016, 0, 28, 11, 30)).getTime(),            
    interval: (1 * 60 * 60 * 1000),
    labelFormatter: function(e){
      return CanvasJS.formatDate(e.value, 'DD - h:mm TT');
    },
    gridThickness: 2
  },

  toolTip:{
    contentFormatter: function ( e ) {
      return '<strong>' + e.entries[0].dataPoint.label + '</strong></br> Start: ' +  CanvasJS.formatDate(e.entries[0].dataPoint.y[0], 'DD - h:mm TT') + '</br>End : ' +  CanvasJS.formatDate(e.entries[0].dataPoint.y[1], 'DD - h:mm TT');  
    }},

  data: [
    {
      type: 'rangeBar',
      dataPoints: [
        { label: 'Walking', y: [(new Date(2016, 0, 28, 12, 20)).getTime(), (new Date(2016, 0, 28, 13, 00)).getTime()] },
        { label: 'Walking', y: [(new Date(2016, 0, 28, 15, 20)).getTime(), (new Date(2016, 0, 28, 18, 00)).getTime()] },
        { label: 'Running', y: [(new Date(2016, 0, 28, 13, 20)).getTime(), (new Date(2016, 0, 28, 14, 20)).getTime()] },
        { label: 'Walking', y: [(new Date(2016, 0, 28, 14, 20)).getTime(), (new Date(2016, 0, 28, 15, 00)).getTime()] }
      ]
    }
  ]                      
});
chart.render(); -->